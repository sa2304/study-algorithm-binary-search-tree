#ifndef BSTREE_H
#define BSTREE_H


#include <iostream>
using namespace std;

template <class TKey, class TValue>
class BSTree {
private:

    /** Класс, представляющий узел дерева */
    class Node {
    public:
        Node(const TKey & key, const TValue & value)
        : _left_child(NULL),
        _right_child(NULL),
        _parent(NULL) {
            this->_key = key;
            this->_value = value;
        }

        //---------------------------------------------------------------------
        /** Возвращает ключ данного узла */
        TKey key() const {
            return _key;
        }

        //---------------------------------------------------------------------
        /** Присваивает новый ключ узлу */
        void setKey(const TKey & key) {
            _key = key;
        }

        //---------------------------------------------------------------------
        /** Возвращает значение данного узла */
        TValue value() const {
            return _value;
        }

        //---------------------------------------------------------------------
        /** Присваивает новое значение узлу */
        void setValue(const TValue & value) {
            _value = value;
        }

        //---------------------------------------------------------------------
        /** Возвращает указатель на корень правого поддерева */
        Node* rightChild() const {
            return _right_child;
        }

        //---------------------------------------------------------------------
        /** Устанавливает корень правого поддерева
         *
         * Если указатель child не равен NULL, производит проверку, не является
         * ли он уже одним из потомкков данного узла */
        void setRightChild(Node * child) {
            // Если производится вызов с параметром NULL, установить NULL-значение
            if(NULL == child) {
                unsetRightChild();
            }
            // Если узел child еще не является потомком данного узла
            else if (!hasChild(child)) {
                _right_child = child;
                if (child) {
                    child->setParent(this);
                }
            }
        }

        //---------------------------------------------------------------------
        /** Возвращает указатель на корень левого поддерева */
        Node* leftChild() const {
            return _left_child;
        }

        //---------------------------------------------------------------------
        /** Устанавливает корень левого поддерева
         *
         * Если указатель child не равен NULL, производит проверку, не является
         * ли он уже одним из потомкков данного узла */
        void setLeftChild(Node * child) {
            // Если производится вызов с параметром NULL, установить NULL-значение
            if (NULL == child) {
                unsetLeftChild();
            }
            // Если узел child еще не является потомком данного узла
            else if (!hasChild(child)) {
                _left_child = child;
                if (child) {
                    child->setParent(this);
                }
            }
        }

        //---------------------------------------------------------------------
        /** Обнуляет указатель на корень левого поддерева */
        void unsetLeftChild() {
            _left_child = NULL;
        }

        //---------------------------------------------------------------------
        /** Обнуляет указатель на корень правого поддерева */
        void unsetRightChild() {
            _right_child = NULL;
        }

        //---------------------------------------------------------------------
        /** Возвращает указатель на родительский узел */
        Node* parent() const {
            return _parent;
        }

        //---------------------------------------------------------------------
        /** Устанавливает указатель на родительский узел */
        void setParent(Node* node) {
            _parent = node;
        }

        //---------------------------------------------------------------------
        /** Возвращает TRUE, если узел является корнем основного дерева, иначе - FALSE */
        bool isRoot() const {
            return parent() == NULL;
        }

        //---------------------------------------------------------------------
        /** Разрывает связь узла с потомком.
         *
         * Иными словами, метод обнуляет соответствующий указатель на узел child,
         * если он является корнем левого/правого поддерева данного узла */
        void unlinkChild(Node* child) {
            if (rightChild() == child) {
                setRightChild(NULL);
            }
            else if (leftChild() == child) {
                setLeftChild(NULL);
            }
        }

        //---------------------------------------------------------------------
        /** Замещает указатель на левого/правого потомка child указателем replacement, если он является одним из потомков данного узла
         *
         * @param child Узел, который в данный момент является корнем левого или правого поддерева текущего узла
         * @param replacement Узел, который будет помещен на место child */
        void replaceChild(Node* child, Node* replacement) {
            if (leftChild() == child) {
                setLeftChild(replacement);
            }
            else if(rightChild() == child) {
                setRightChild(replacement);
            }
        }

        //---------------------------------------------------------------------
        /** Возвращает TRUE, если указанный узел child является корнем левого/правого поддерева текущего узла */
        bool hasChild(Node* child) const {
            return ( (leftChild() == child) ||
                    (rightChild() == child) );
        }

    private:
        Node* _left_child;
        Node* _right_child;
        Node* _parent;
        TKey _key;
        TValue _value;



    };

    Node* _root;

    //---------------------------------------------------------------------
    /** Возвращает указатель на узел с наименьщим значением ключа из всех узлов поддерева с корнем root
     *
     * Учитывая структуру двоичного дерева поиска и расположение младших ключей в левых ветках дерева,
     * метод просто спускается до самого конца, всё время выбирая левых потомков узлов и возвращает
     * указатель на последний найденный узел, который больше не имеет левого поддерева
     *
     * @param Указатель на корень поддерева, в котором осуществлять поиск */
    Node* _findNodeWithSmallestKey(Node* root) {
        // Спускаться до конца по левой ветке двоичного поддерева
        Node* node_next = root;
        while (node_next->leftChild()) {
            node_next = node_next->leftChild();
        }

        return node_next;
    }

    //---------------------------------------------------------------------
    /** Устанавливает новый корень дерева */
    void _setRootNode(Node* node) {
        _root = node;
        if (node) {
            node->setParent(NULL);
        }
    }

    //---------------------------------------------------------------------
    /** Производит удаление указанного узла из дерева с сохранением корректной структуры двоичного дерева поиска */
    void _removeNode(Node* node_to_remove) {
        if(node_to_remove) {
            /* Родитель удаляемого узла. Может иметь значение NULL, когда удаляемый узел является корнем
                     * основного дерева */
            // Если удаляемый узел не имеет родительского узла, он является корнем дерева
            Node* node_parent = node_to_remove->parent();
            bool has_left_child = (node_to_remove->leftChild() != NULL);
            bool has_right_child = (node_to_remove->rightChild() != NULL);
            bool has_single_child =
                    (has_left_child && !has_right_child) ||
                    (has_right_child && !has_left_child);
            bool has_both_children = (has_left_child && has_right_child);

            // Если узел имеет единственного потомка
            if (has_single_child) {
                Node* node_child_to_move = NULL;
                // Если единственный потомок удаляемого узла - левый
                if (has_left_child) {
                    node_child_to_move = node_to_remove->leftChild();
                    // Иначе единственный потомок удаляемого узла - правый
                } else {    // if (has_right_child)
                    node_child_to_move = node_to_remove->rightChild();
                }

                /* Заменить в родительском узле указатель на удаляемый узел
                         * указателем на этого единственного потомка */
                // Если удаляемый узел является корнем дерева
                if (node_to_remove->isRoot()) {
                    _setRootNode(node_child_to_move);
                }

                else {
                    node_parent->replaceChild(node_to_remove, node_child_to_move);
                }
            }

            // Иначе если узел имеет обоих потомков
            // Найти в правом поддереве узел с наименьшим ключом
            // и поместить его на место удаляемого.
            else if (has_both_children) {
                Node* node_replacement = _findNodeWithSmallestKey(node_to_remove->rightChild());
                /* Узел с наименьшим значением ключа - лист. Чтобы отделить его от ветки дерева,
                         * обнулим указатель на него в родителе */
                node_replacement->parent()->unlinkChild(node_replacement);
                // Помещаем узел на место удаляемого, связывая его с потомками
                node_replacement->setLeftChild(node_to_remove->leftChild());
                node_replacement->setRightChild(node_to_remove->rightChild());

                // Присоединим перемещенный узел к иерархии дерева выше
                // Если удаляемый узел является корнем дерева
                if (node_to_remove->isRoot()) {
                    // Установить новый корень дерева
                    _setRootNode(node_replacement);
                }
                // Иначе связать родительский узел удаляемого узла с новым потомком
                else {
                    node_parent->replaceChild(node_to_remove, node_replacement);
                }
            }

            // Иначе узел не имеет потомков
            else {
                // Если удаляемый узел является корнем дерева
                if (node_to_remove->isRoot()) {
                    // Обнулить указатель на корень
                    _setRootNode(NULL);
                    // Иначе обнулить в родительском узле указатель на удаляемый узел
                } else {
                    node_parent->unlinkChild(node_to_remove);
                }
            }

            // После внесения необходимых изменений в структуру дерева узел уничтожается
            delete node_to_remove;
        }
    }

    //---------------------------------------------------------------------
    /** Возвращает указатель на корень дерева */
    Node* _rootNode() const {
        return _root;
    }

    //---------------------------------------------------------------------
    /** Ищет узел с заданным ключом в поддереве
     *
     * @param key Ключ для поиска
     * @param node_root Корень поддерева
     */
    Node* _findNode(const TKey & key, Node* node_root) const {
        if (!node_root) {
            return NULL;
        }

        // Если узел содержит искомый ключ, вернуть указатель на него
        if (node_root->key() == key) {
            return node_root;
        }
        // Иначе продолжить поиск в поддеревьях, вызывая функцию рекурсивно
        else {
            Node* node_found_in_left_subtree = _findNode(key, node_root->leftChild());
            Node* node_found_in_right_subtree = _findNode(key, node_root->rightChild());
            if (node_found_in_left_subtree) {
                return node_found_in_left_subtree;
            } else {
                return node_found_in_right_subtree;
            }
        }
    }

    //---------------------------------------------------------------------
    /** Производит вставку указанного узла в поддерево с корнем node_root
     *
     * Метод последовательно спускается по узлам дерева в поиске подходящего места
     * для нового узла на основе значения его ключа */
    void _insertNode(Node* node_to_insert, Node* node_root) {
        // Если ключ нового узла меньше ключа вершины поддерева
        if (node_to_insert->key() < node_root->key()) {
            // и левое поддерево отсутствует
            if (!node_root->leftChild()) {
                // сделать новый узел новым корнем левого поддерева
                node_root->setLeftChild(node_to_insert);
            }
            // Иначе продолжить поиск позиции для вставки по левому поддереву
            else {
                _insertNode(node_to_insert, node_root->leftChild());
            }
        }
        // Если ключ нового узла больше ключа вершины поддерева
        else if (node_root->key() < node_to_insert->key()) {
            // и правое поддерево отсутствует
            if (!node_root->rightChild()) {
                // сделать новый узел новым корнем правого поддерева
                node_root->setRightChild(node_to_insert);
            }
            else {
                // Иначе продолжить поиск позиции для вставки по правому поддереву
                _insertNode(node_to_insert, node_root->rightChild());
            }
        }
    }

    //---------------------------------------------------------------------
    /** Возвращает число узлов в поддереве с корнем root */
    int _countNodes(Node* root) const {
        if(!root) {
            return 0;
        }

        int left_children_count = _countNodes(root->leftChild());
        int right_children_count = _countNodes(root->rightChild());

        /* Общее количество узлов складывается из узлов в левом и правом поддеревьях,
         * а также учитывается сам корневой узел */
        return left_children_count + right_children_count + 1;
    }

    //---------------------------------------------------------------------
    //---------------------------------------------------------------------
    //---------------------------------------------------------------------
    //---------------------------------------------------------------------
public:
    BSTree()
        : _root(NULL)
    {
    }

    //---------------------------------------------------------------------
    ~BSTree() {
        clear();
    }

    //---------------------------------------------------------------------
    /** Возвращает TRUE, если дерево не содержит узлов, иначе - FALSE */
    bool isEmpty() const {
        return (NULL == _root);
    }

    //---------------------------------------------------------------------
    /** Производит вставку в дерево нового узла, создав его и присвоив ему указанные ключ и значение */
    void insert(const TKey & key, const TValue & value) {
        Node* node_to_insert = new Node(key, value);
        node_to_insert->setKey(key);
        node_to_insert->setValue(value);
        // Если в дереве еще нет узлов, новый узел станет корнем
        if (isEmpty()) {
            _root = node_to_insert;
        }
        else {
            /* Найти позицию для вставки новоло узла:
             * узлы двоичного дерева поиска упорядочены так, что ключ любого
             * родительского узла больше ключа любого узла-потомка из левой ветки
             * и меньше ключа любого узла-потомка из правой ветки. */
            _insertNode(node_to_insert, _rootNode());
        }
    }

    //---------------------------------------------------------------------
    /** Возвращает TRUE, если дерево содержит узел с указанным ключом */
    bool hasKey(const TKey & key) {
        Node* node = _findNode(key, _rootNode());
        return (NULL != node);
    }

    //---------------------------------------------------------------------
    /** Удаляет из дерева узел с указанным ключом, если таковой имеется */
    void remove(TKey key) {
            // Найти элемент с заданным ключом
        Node* node_to_remove = _findNode(key, _rootNode());
        // Если узел найден
        if (node_to_remove) {
            _removeNode(node_to_remove);
        }
    }

    //---------------------------------------------------------------------
    /** Возвращает количество узлов в дереве */
    int count() const {
        /* Используется вызов рекурсивной функции */
        return _countNodes(_rootNode());
    }

    //---------------------------------------------------------------------
    /** Удаляет все узлы дерева */
    void clear() {
        while (_root) {
            _removeNode(_root);
        }
    }
    //---------------------------------------------------------------------
    /** Оператор, позволяющий работать с ммножеством узлов дерева как с массивом пар ключ/значение
     *
     * Например, для дерева, кранящего целочисленные ключи и строковые значения <int, std::string>
     * можно использовать в коде такие выражения:
     *
     * tree[1] = "one";
     * tree[2] = "two";
     * tree[3] = "three";
     * tree[7] = "seven";
     *
     * автоматически создавая новые узлы и инициализируя их значениями, или перезаписывая уже существующие
     *
     * tree[1] = "один";
     */
    TValue & operator[] (TKey key) {
        Node* node = _findNode(key, _rootNode());
        /* Если узел с запрошенным ключом отсутствует, создать новый
         * с неинициализированным значением и вернуть ссылку на него */
        if(NULL == node) {
            insert(key, new TValue());
            node = _findNode(key, _rootNode());
        }
        return node->_value;
    }

    //---------------------------------------------------------------------
    //---------------------------------------------------------------------
    //---------------------------------------------------------------------
    //---------------------------------------------------------------------
    //---------------------------------------------------------------------
    //---------------------------------------------------------------------
    //---------------------------------------------------------------------
    //---------------------------------------------------------------------
    //---------------------------------------------------------------------
    //---------------------------------------------------------------------
    //---------------------------------------------------------------------
    //---------------------------------------------------------------------
    //---------------------------------------------------------------------
    //---------------------------------------------------------------------
    //---------------------------------------------------------------------
    //---------------------------------------------------------------------
    //---------------------------------------------------------------------
    //---------------------------------------------------------------------
    //---------------------------------------------------------------------
    //---------------------------------------------------------------------
    //---------------------------------------------------------------------
    //---------------------------------------------------------------------

    friend class TestBSTree;
};


#endif // BSTREE_H
